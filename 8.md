# 8.スキーマオブジェクトの管理

## 1.スキーマ

### 1.スキーマとは

* あるユーザが所有する表などの**オブジェクトを格納する箱のようなもの**
* ユーザを作成すると、ユーザ名と同名のスキーマが自動的に作成される
    * そのユーザが表などのオブジェクトを作成すると、そのユーザがそれらのオブジェクトの所有者となる
    * オブジェクトは、そのユーザの名前がついたスキーマに格納される

### 2.スキーマオブジェクトと非スキーマオブジェクト

* スキーマオブジェクト：スキーマに格納されるオブジェクト
    * 表とか
    * 索引とか
* 非スキーマオブジェクト：スキーマに格納されないオブジェクト
    * ユーザとか
    * ロールとか

### 3.スキーマと権限

* 自スキーマに格納されたオブジェクトを読み書きできるのは、スキーマに対応するユーザと、権限が与えられたユーザのみ
* 権限が付与されない限り、他スキーマに格納されたオブジェクトへのアクセスは不可能

### 4.名前空間としてのスキーマ

* オブジェクトの名前の衝突を防ぐ**名前空間**としての役割を持つ
* ユーザA、ユーザBそれぞれで**t1**という名前のテーブルを作成可能
* SQLで指定する場合、`SELECT * FROM <ユーザA>.t1;`となる

## 2.データ型・制約と表の作成

### 1.データ型

* 表の、それぞれのカラムに指定する
* その種類のデータしか格納できない

* NUMBER型
    * 整数、小数を格納するためのデータ型
    * NUMBER(n):n桁の整数。n:1~38
    * NUMBER(n,m):最大有効桁数n、小数点以下の最大桁数mの小数または整数。n:1~38
    * NUMBER型で対応できる最大の制度を指定したことになる
* CHAR型
  * 固定長文字列
  * CHAR(n):最大バイト数：nの文字列
    * ex:CHAR(10)のカラムに'ABCD'を格納すると、'ABCD______'が格納される
* VARCHAR2型
  * 可変長文字列
  * VARCHAR2(n):最大バイト数
    * ex:VARCHAR2(10)のカラムに'ABCD'を格納すると、'ABCD'が格納される
* BLOB型
  * 画像や音声などのバイナリデータを格納するためのデータ型
* CLOB型
  * CHAR,VARCHAR2で対応できない大きなサイズの文字列：テキストデータを格納するためのデータ型
* DATE型/TIMESTAMP型
  * 日付と時刻のデータ
  * DATE型は、年月日時分秒まで
    * 2021/01/06 12:34:56
  * TIMESTAMP型は、年月日時分秒+小数秒(3桁)まで
    * 2021/01/06 12:34:56.789

### 2.制約
* 表に無効なデータが入ることを禁止するールール
* NOTNULL
  * NULL禁止
* UNIQUE
  * 重複値禁止
  * NULLは禁止されてない
  * 索引が自動的に作成される
* PRIMARY KEY
  * 1件の行データを特定するために使える列
  * 重複値禁止
  * NULLも禁止
  * 1つの表に定義されるPRIMARY KEYは1つだけ
  * 索引が自動的に作成される
* FOREIGN KEY
  * 外部キー制約
  * 参照キーにある値しか使ってはいけない
  * 親表の参照キーにはUNIQUEorPRIMARY KEYが必要
    * 参照キーのデータが複数件存在しちゃいけないからね

* CHECK
  * 条件を指定してあげる制約
  * ex:入社日カラムは、2000年1月16日以降でなければいけない
  * ex:給料カラムは、500万円以上

### 3.表の作成
* CREATE TABLEコマンドで作成する
* もちろん権限必要だよ
```
CREATE TABLE products
(
  prop id  NUMBER  CONSTRAINTS PRODUCTS_PK PRIMARY_KEY,
  prod_name  VARCHAR2(20)  CONSRAINTS  PRODUCTS_UK UNIQUE,
  prod_price  NUMBER  CONSTRAINTS PRODUCTS_CHK1 CHECK(prod_price >= 0)
);
```
* 表の名前は30バイト以内(12c R1以前)/128バイト以内(12c R2以降)
* 英数字、$_#以外の文字列を使う場合はダブルクォートで括る
  * 先頭にアルファベット以外のときも
  * 予約後の時も
* スキーマ内では名前を一意に保つこと

## 3.表の削除とゴミ箱
### 1.表の削除
* DROP TABLEコマンド
```
DROP TABLE <表名>;
```
* 表に格納されていたデータも削除される
* 索引も制約も削除される
### 2.ゴミ箱とフラッシュバックドロップ
* 削除した表はゴミ箱に入る
  * 実体は論理削除されているだけ
  * 依然として表領域に格納されてる
* フラッシュバックドロップ：ゴミ箱から表を復元する機能
  * RECYCLEBIN初期化パラメータをONに設定しておく
    * デフォルトでON
    * OFFにするとフラッシュバック機能は使えない
```
FLASHBACK TABLE <表名> TO BEFORE DROP;
```
## 4.索引とビュー
### 1.索引
* インデックスのこと
* 列に対して作成する
* CREATE INDEXコマンドで作成する
* 検索条件にマッチする行を高速に探せる
* n分探索木でアドレスを探す
* 検索にマッチするデータの件数が少ない場合、処理が高速化可能
* 検索にマッチするデータの件数が多い場合、表のデータを全件読み出すほうが効率的
* オプティマイザが索引を使用する/しないの判断を行う
* 1つの表に多数のインデックスを貼ると、データ更新時の負荷が増加する
  * 行データの索引列が更新されるたび、索引のメンテナンス処理が実行されるため
* 表が削除されると、索引も一緒に削除される
* PRIMARY KEY/UNIQUE制約を設定すると、索引も自動的に作成される

### 2.ビュー
* 表に対するSELECT文により定義されるスキーマオブジェクト
* CREATE VIEWコマンドでSELECT文を指定すると作成できる
* 複雑な問い合わせを隠蔽し、データアクセスのり弁性を向上させる
* ユーザに、ビューへの参照権限のみを付与すると、アクセス可能範囲を制限できる
* ビューにはデータが格納されない
* ビューに対してDML(INSERT/UPDATE/DELETE)を発行すると、ビューが詐称している実ひょうのデータが更新される
* ビューを使用しても特にSQL処理が高速化できるわけではない
  * 結局実表からデータが取得されるからね

## 5.データの管理
### 1.SQL*Loader
* CSVをDBAの表にロードするツール
* Oracleソフトウェアに含まれる
* データファイル(csv等のテキストファイル)と、データをロードするための制御ファイルが必要

### 2.Data Pump
* OracleDB間でデータを移動するツール
* expdp
  * DBからデータをダンプファイルにエクスポートする
* impdp
  * データを含むダンプファイルをDBにインポートする
* 異なるOS間で動作するDB間のデータ移動可能
* 異なるリリースのDB間でもデータ移動可能
* 表単位でのデータ移動可能
  * スキーマ単位、表領域単位でも可能
  * DB全体のエクスポートも可能